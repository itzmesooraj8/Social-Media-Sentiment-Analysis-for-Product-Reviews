-- 04_finalize_production.sql
-- Run this AFTER 01_init_core.sql to finish setting up the "Real World" database.
-- It is idempotent (safe to run multiple times).

-- 1. Auxiliary Tables (Alerts, Integrations, Topics)
CREATE TABLE IF NOT EXISTS alerts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  type TEXT NOT NULL,
  severity TEXT NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  platform TEXT,
  is_read BOOLEAN DEFAULT false,
  is_resolved BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  details JSONB
);

CREATE TABLE IF NOT EXISTS integrations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  platform TEXT NOT NULL UNIQUE,
  status TEXT DEFAULT 'inactive',
  last_sync TIMESTAMP WITH TIME ZONE,
  api_key TEXT,
  is_enabled BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS topic_analysis (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  topic_name TEXT NOT NULL,
  sentiment NUMERIC,
  size INTEGER,
  keywords TEXT[],
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. User Settings (with RLS)
CREATE TABLE IF NOT EXISTS user_settings (
    user_id UUID REFERENCES auth.users(id),
    setting_key TEXT NOT NULL,
    setting_value JSONB,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    PRIMARY KEY (user_id, setting_key)
);
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can view own settings') THEN
        CREATE POLICY "Users can view own settings" ON user_settings FOR SELECT USING (auth.uid() = user_id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can update own settings') THEN
        CREATE POLICY "Users can update own settings" ON user_settings FOR UPDATE USING (auth.uid() = user_id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can insert own settings') THEN
        CREATE POLICY "Users can insert own settings" ON user_settings FOR INSERT WITH CHECK (auth.uid() = user_id);
    END IF;
END $$;


-- 3. Security Policies for Aux Tables (Open for Demo, tighten for Prod if needed)
ALTER TABLE alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE integrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE topic_analysis ENABLE ROW LEVEL SECURITY;

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Enable all access for alerts') THEN
        CREATE POLICY "Enable all access for alerts" ON alerts FOR ALL USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Enable all access for integrations') THEN
        CREATE POLICY "Enable all access for integrations" ON integrations FOR ALL USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Enable all access for topic_analysis') THEN
        CREATE POLICY "Enable all access for topic_analysis" ON topic_analysis FOR ALL USING (true) WITH CHECK (true);
    END IF;
END $$;


-- 4. Dashboard Stats Function (Critical for Dashboard)
DROP FUNCTION IF EXISTS get_dashboard_stats();

CREATE OR REPLACE FUNCTION get_dashboard_stats()
RETURNS json
LANGUAGE plpgsql
AS $$
DECLARE
  total_count INTEGER;
  avg_sentiment NUMERIC;
  avg_credibility NUMERIC;
  platform_counts JSON;
BEGIN
  -- Get total reviews
  SELECT count(*) INTO total_count FROM reviews;

  -- Get Averages
  SELECT 
    COALESCE(AVG(
      CASE 
        WHEN label = 'POSITIVE' THEN 100 
        WHEN label = 'NEUTRAL' THEN 50 
        ELSE 0 
      END
    ), 0),
    COALESCE(AVG(credibility), 0)
  INTO avg_sentiment, avg_credibility
  FROM sentiment_analysis;

  -- Get Platform Breakdown
  SELECT json_object_agg(platform, count)
  INTO platform_counts
  FROM (
    SELECT platform, count(*) as count
    FROM reviews
    GROUP BY platform
  ) p;

  RETURN json_build_object(
    'totalReviews', total_count,
    'sentimentScore', avg_sentiment,
    'averageCredibility', avg_credibility,
    'platformBreakdown', COALESCE(platform_counts, '{}'::json)
  );
END;
$$;


-- 5. Production Performance Indexes
CREATE INDEX IF NOT EXISTS idx_reviews_created_at ON reviews(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_reviews_platform ON reviews(platform);
CREATE INDEX IF NOT EXISTS idx_sentiment_analysis_score ON sentiment_analysis(score);


-- 6. Analytics Reporting View
CREATE OR REPLACE VIEW analytics_summary AS
SELECT
    DATE(r.created_at) as report_date,
    COUNT(r.id) as total_daily_reviews,
    ROUND(AVG(COALESCE(s.score, 0.5))::numeric, 2) as avg_sentiment,
    ROUND(AVG(COALESCE(s.credibility, 0))::numeric, 2) as avg_credibility,
    jsonb_build_object(
        'twitter', COUNT(*) FILTER (WHERE r.platform = 'twitter'),
        'reddit', COUNT(*) FILTER (WHERE r.platform = 'reddit'),
        'youtube', COUNT(*) FILTER (WHERE r.platform = 'youtube'),
        'forums', COUNT(*) FILTER (WHERE r.platform = 'forums')
    ) as platform_breakdown
FROM
    reviews r
LEFT JOIN
    sentiment_analysis s ON r.id = s.review_id
GROUP BY
    DATE(r.created_at)
ORDER BY
    DATE(r.created_at) DESC;
